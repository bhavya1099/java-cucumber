// ********RoostGPT********
/*
Test generated by RoostGPT for test test-workflow using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=sayHello_52ad62746f
ROOST_METHOD_SIG_HASH=sayHello_26998730d5

================================VULNERABILITIES================================
Vulnerability: Uncontrolled String Format String (CWE-134)
Issue: The use of uncontrolled format strings can lead to vulnerabilities when the format string originates from a non-trusted source. It may lead to denial of service, information exposure, or possibly remote code execution. In this code, there is no such vulnerability, but it's important to be aware of CWE-134 while writing Java code.
Solution: Always use controlled format strings. Do not allow users to supply all or a majority of a format string in Java. If user input is used to construct a format string, ensure the format string is constant and clearly specifies the proper format for input.

Vulnerability: Improper Control of Generation of Code ('Code Injection') (CWE-94)
Issue: If untrusted input is allowed to be part of the code that's generated and executed, it can lead to arbitrary code execution. This code is not currently vulnerable to code injection, but it's important to be aware of CWE-94 while writing Java code.
Solution: A key question to mitigate code injection vulnerabilities is, 'Can the user input be separated from the code execution?' If so, that's a strong defense. Additionally, using safe APIs and libraries, or validating user input against whitelists of acceptable inputs, can further reduce the risk of code injection vulnerabilities.

================================================================================
Scenario 1: Test Method returns Expected String
  Details:
    TestName: testSayHelloReturnsExpected
    Description: This test is meant to check, if the method sayHello returns the expected string "Hello World!".
  Execution:
    Arrange: No setup is required as the method does not take any parameters.
    Act: Invoke the sayHello method.
    Assert: Use JUnit assertions to ensure the returned string is equal to "Hello World!".
  Validation:
    The assertion aims to verify that the method returns "Hello World!". This is the expected result because the method is hardcoded to return this string. The test is significant in that it guarantees the method behaves as expected and correctly returns the correct string.

Scenario 2: Test Method return Type
  Details:
    TestName: testSayHelloReturnsStringType
    Description: This test is meant to check, if the return type of method sayHello is String.
  Execution:
    Arrange: No setup is required as the method does not take any parameters.
    Act: Invoke the sayHello method.
    Assert: Use JUnit assertions to ensure the returned type is equal to String class.
  Validation:
    The assertion aims to verify the returned type by sayHello method is String. This is the expected result because as per the definition of the function, it is hardcoded to return the string. The test guarantees that the method continues to return data of the correct type, even if changes are made in the future.

Scenario 3: Test Method output Equals Ignore Case
  Details:
    TestName: testSayHelloReturnsCaseInsensitive
    Description: This test is meant to check if the method sayHello returns the expected string "Hello World!" while ignoring case sensitivity.
  Execution:
    Arrange: No setup is required as the method does not take any parameters.
    Act: Invoke sagenHello method.
    Assert: Use JUnit assertions to ensure the returned string is equal to "hElLo WOrLd!" ignoring case.
  Validation:
    The assertion aims to verify that the sayHello method returns "Hello World!" regardless of case sensitivity. This is the expected result because the method is hardcoded to return this string, regardless of how it's cased. This test is significant as it checks that the method behaves as expected under different circumstances.
*/

// ********RoostGPT********
package br.masmangan.beecrowd.bee1000;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class GreeterSayHelloTest {

	@Test
	public void testSayHelloReturnsExpected() {
		Greeter greeter = new Greeter();
		String expected = "Hello World!";
		String actual = greeter.sayHello();
		assertEquals(expected, actual);
	}

	@Test
	public void testSayHelloReturnsStringType() {
		Greeter greeter = new Greeter();
		String actual = greeter.sayHello();

		assertEquals(String.class, actual.getClass());
	}

	@Test
	public void testSayHelloReturnsCaseInsensitive() {
		Greeter greeter = new Greeter();
		String expected = "hElLo WOrLd!";
		String actual = greeter.sayHello();
		assertEquals(expected.toLowerCase(), actual.toLowerCase());
	}

}