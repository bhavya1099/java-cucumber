// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620
ROOST_METHOD_HASH=getAverage_cd4fabe1ad
ROOST_METHOD_SIG_HASH=getAverage_5d8b4919d3
Based on the provided method and class information, here are several JUnit test scenarios for the `getAverage()` method:
Scenario 1: Calculate Average with Positive Values
Details:
  TestName: calculateAverageWithPositiveValues()
  Description: Verify that the method correctly calculates the average when both 'a' and 'b' are positive values.
Execution:
  Arrange: Set 'a' to 10.0 and 'b' to 20.0
  Act: Call getAverage()
  Assert: Compare the result with the expected value of (10.0 * 3.5 + 20.0 * 7.5) / 11.0
Validation:
  This test ensures that the method correctly applies the weighted average formula for typical positive inputs. It's crucial for verifying basic functionality with standard inputs.
Scenario 2: Calculate Average with Negative Values
Details:
  TestName: calculateAverageWithNegativeValues()
  Description: Check if the method correctly handles negative values for both 'a' and 'b'.
Execution:
  Arrange: Set 'a' to -5.0 and 'b' to -10.0
  Act: Call getAverage()
  Assert: Compare the result with the expected value of (-5.0 * 3.5 + -10.0 * 7.5) / 11.0
Validation:
  This test verifies that the method works correctly with negative inputs, ensuring it doesn't have any sign-related issues in the calculation.
Scenario 3: Calculate Average with Zero Values
Details:
  TestName: calculateAverageWithZeroValues()
  Description: Verify the method's behavior when both 'a' and 'b' are set to zero.
Execution:
  Arrange: Set both 'a' and 'b' to 0.0
  Act: Call getAverage()
  Assert: Expect the result to be 0.0
Validation:
  This test checks if the method handles the edge case of zero inputs correctly, which is important for ensuring robustness in various scenarios.
Scenario 4: Calculate Average with Large Positive Values
Details:
  TestName: calculateAverageWithLargePositiveValues()
  Description: Test the method's accuracy with very large positive values for 'a' and 'b'.
Execution:
  Arrange: Set 'a' to Double.MAX_VALUE / 4 and 'b' to Double.MAX_VALUE / 4
  Act: Call getAverage()
  Assert: Compare the result with the expected large value calculation
Validation:
  This test ensures that the method can handle large values without overflow or loss of precision, which is crucial for maintaining accuracy in extreme scenarios.
Scenario 5: Calculate Average with Large Negative Values
Details:
  TestName: calculateAverageWithLargeNegativeValues()
  Description: Verify the method's behavior with very large negative values for 'a' and 'b'.
Execution:
  Arrange: Set 'a' to -Double.MAX_VALUE / 4 and 'b' to -Double.MAX_VALUE / 4
  Act: Call getAverage()
  Assert: Compare the result with the expected large negative value calculation
Validation:
  This test checks if the method correctly handles large negative values, ensuring consistency in calculations across the full range of possible inputs.
Scenario 6: Calculate Average with Mixed Positive and Negative Values
Details:
  TestName: calculateAverageWithMixedValues()
  Description: Test the method's accuracy when 'a' is positive and 'b' is negative (or vice versa).
Execution:
  Arrange: Set 'a' to 15.5 and 'b' to -7.25
  Act: Call getAverage()
  Assert: Compare the result with the expected value of (15.5 * 3.5 + -7.25 * 7.5) / 11.0
Validation:
  This test verifies that the method correctly handles a mix of positive and negative inputs, which is important for real-world scenarios where inputs can vary in sign.
Scenario 7: Calculate Average with Minimum Double Values
Details:
  TestName: calculateAverageWithMinimumDoubleValues()
  Description: Check the method's behavior when both 'a' and 'b' are set to the smallest positive double value.
Execution:
  Arrange: Set both 'a' and 'b' to Double.MIN_VALUE
  Act: Call getAverage()
  Assert: Compare the result with the expected calculation using Double.MIN_VALUE
Validation:
  This test ensures that the method can handle the smallest possible positive double values without losing precision or returning unexpected results.
These scenarios cover a range of typical cases, edge cases, and potential error conditions for the `getAverage()` method, providing a comprehensive test suite for this functionality.
*/
// ********RoostGPT********
package br.masmangan.beecrowd.bee1005;

import org.junit.Before;
import org.junit.Test;
import org.junit.experimental.categories.Category;
import static org.junit.Assert.*;
import org.junit.experimental.categories.Category;

@Category({ Categories.getAverage.class })
public class StudentGradeGetAverageTest {

	private StudentGrade studentGrade;

	@Before
	public void setUp() {
		studentGrade = new StudentGrade();
	}

	@Test
	@Category(Categories.valid.class)
	public void calculateAverageWithPositiveValues() {
		studentGrade.setA(10.0);
		studentGrade.setB(20.0);
		double expected = (10.0 * 3.5 + 20.0 * 7.5) / 11.0;
		assertEquals(expected, studentGrade.getAverage(), 0.0001);
	}

	@Test
	@Category(Categories.valid.class)
	public void calculateAverageWithNegativeValues() {
		studentGrade.setA(-5.0);
		studentGrade.setB(-10.0);
		double expected = (-5.0 * 3.5 + -10.0 * 7.5) / 11.0;
		assertEquals(expected, studentGrade.getAverage(), 0.0001);
	}

	@Test
	@Category(Categories.boundary.class)
	public void calculateAverageWithZeroValues() {
		studentGrade.setA(0.0);
		studentGrade.setB(0.0);
		assertEquals(0.0, studentGrade.getAverage(), 0.0001);
	}

	@Test
	@Category(Categories.boundary.class)
	public void calculateAverageWithLargePositiveValues() {
		double largeValue = Double.MAX_VALUE / 4;
		studentGrade.setA(largeValue);
		studentGrade.setB(largeValue);
		double expected = (largeValue * 3.5 + largeValue * 7.5) / 11.0;
		assertEquals(expected, studentGrade.getAverage(), 0.0001);
	}

	@Test
	@Category(Categories.boundary.class)
	public void calculateAverageWithLargeNegativeValues() {
		double largeNegativeValue = -Double.MAX_VALUE / 4;
		studentGrade.setA(largeNegativeValue);
		studentGrade.setB(largeNegativeValue);
		double expected = (largeNegativeValue * 3.5 + largeNegativeValue * 7.5) / 11.0;
		assertEquals(expected, studentGrade.getAverage(), 0.0001);
	}

	@Test
	@Category(Categories.valid.class)
	public void calculateAverageWithMixedValues() {
		studentGrade.setA(15.5);
		studentGrade.setB(-7.25);
		double expected = (15.5 * 3.5 + -7.25 * 7.5) / 11.0;
		assertEquals(expected, studentGrade.getAverage(), 0.0001);
	}

	@Test
	@Category(Categories.boundary.class)
	public void calculateAverageWithMinimumDoubleValues() {
		studentGrade.setA(Double.MIN_VALUE);
		studentGrade.setB(Double.MIN_VALUE);
		double expected = (Double.MIN_VALUE * 3.5 + Double.MIN_VALUE * 7.5) / 11.0;
		assertEquals(expected, studentGrade.getAverage(), 0.0001);
	}

}